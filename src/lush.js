'use strict';
/*
 * LUSH
 * Blueprint Parser
 * Frontend JS parser for Blueprint Markdown
 * @author Bob van Luijt <bob.van.luijt@ing.nl>
 */

/**
 * Function to create markdown from lush HTML
 * NOTE: This function assumes that it gets a LUSH element as generated by the lush function!
 * NOTE: For now this only support one column
 *
 * @param   {string}  title     Title of the Blueprint
 * @param   {obj}     ELEMENT   Element object
 * @returns {obj}     Returns object with the title and the markdown
 */
function lush2markdown(title, scenario, ELEMENT){

  console.log(title);

  /**
   * Add the service
   */
  var returner  = '$ Service' + '\n';
      returner += title + '\n\n';
      returner += '$ Scenario' + '\n';
      returner += scenario + '\n\n';

  ELEMENT
    .find('lush-column')
    .each(function (){
      returner += '\t' + '$ Step' + '\n\n';

      $(this)
        .find('lush-layer')
        .each(function (){
          switch($(this).attr('class')){
            case 'lush-layer-stepdefinition':
              returner += '\t\t\t' + '$ Step Definition' + '\n';
              break;
            case 'lush-layer-channel':
              returner += '\t\t\t' + '$ Channel' + '\n';
              break;
            case 'lush-layer-actor':
              returner += '\t\t\t' + '$ Actor' + '\n';
              break;
            case 'lush-layer-apisystem':
              returner += '\t\t\t' + '$ API, System' + '\n';
              break;
            case 'lush-layer-observationfact':
              returner += '\t\t\t' + '$ Observation, fact' + '\n';
              break;
            case 'lush-layer-policyrule':
              returner += '\t\t\t' + '$ Policy, rule' + '\n';
              break;
            case 'lush-layer-metric':
              returner += '\t\t\t' + '$ Metric' + '\n';
              break;
            case 'lush-layer-criticalmoment':
              returner += '\t\t\t' + '$ Criticalmoment' + '\n';
              break;
            case 'lush-layer-question':
              returner += '\t\t\t' + '$ Question' + '\n';
              break;
            case 'lush-layer-idea':
              returner += '\t\t\t' + '$ Idea' + '\n';
              break;

            default: break;

          }

          returner += '\t\t\t' + toMarkdown($(this).find('lush-content').html()) + '\n\n';

        });
    });
  return {
    title: title,
    markdown: returner
  };

}

/**
 * Translates all urls to dataurls
 *
 * @param   {string}  The url to translate
 * @param   {obj}     The callback
 * @param   {string}  The output format
 * @returns {string}  Returns the dataurl of the image
 */
function toDataUrl(url, callback, outputFormat){
  var img = new Image();
  img.crossOrigin = 'Anonymous';
  img.onload = function(){
      var canvas = document.createElement('CANVAS');
      var ctx = canvas.getContext('2d');
      var dataURL;
      canvas.height = this.height;
      canvas.width = this.width;
      ctx.drawImage(this, 0, 0);
      dataURL = canvas.toDataURL(outputFormat);
      callback(dataURL);
      canvas = null; 
  };
  img.src = url;
}

/**
 * Lush function for creating a lush element
 * @param   {obj}   ELEMENT   The HTML element
 * @returns {null}  Does not return anything
 */
function markdown2lush(ELEMENT) {
  /**
   * Define scope GLOBALS
   *
   * Note: ALLOWED_OPTIONS is set all to lowercase and without $ sign.
   */
  var ALLOWED_OPTIONS = [ 'step',
                'metric',
                'criticalmoment',
                'question',
                'stepdefinition',
                'actor',
                'policy,rule',
                'idea',
                'api,system',
                'observation,fact',
                'service',
                'scenario',
                'channel'],
      CONVERTER   = new showdown.Converter(),
      CURRENTMD = 0,
      LEGEND                     = {},
      MDDATA,
      PARSED,
      SCENARIO  = 0,
      SERVICE   = 0,
      STEP      = 0,
      STEP_I    = 1,
      TABINDEX  = 0;

      LEGEND['actor']            = 'Actor',
      LEGEND['api,system']       = 'API, System',
      LEGEND['criticalmoment']   = 'Critical Moment',
      LEGEND['idea']             = 'Idea',
      LEGEND['metric']           = 'Metric',
      LEGEND['observation,fact'] = 'Observation, Fact',
      LEGEND['policy,rule']      = 'Policy, Rule',
      LEGEND['question']         = 'Question',
      LEGEND['stepdefinition']   = 'Step Definition',
      LEGEND['channel']          = 'Channel';

  /**
   * Build a layer inside a step.
   *
   * @param   {string}  i Text that needs to be converted to MD
   * @param   {int}     k Key location of current item
   * @param   {string}  lt Layer Type contains the type of layer (like: Channel)
   * @param   {string}  ft Full title
   * @returns {null}    Does not return anything
   */
  function buildLayer(i, k, lt, ft){

    /**
     * Removed becuase not in first version: <img class="blueprint_edit" src="./img/edit.svg">
     */

    $('#step_' + STEP)
      .append('<lush-layer class="lush-layer-' + lt.replace(/[^a-zA-Z ]/g, '') +
          '" data-blueprint-type="' + lt.replace(/[^a-zA-Z ]/g, '') +
          '" tabindex="' + TABINDEX + '"><lush-content>' +
          CONVERTER.makeHtml(i.trim()) + '</lush-content></lush-layer>');
    TABINDEX++;
  }

  /**
   * Build a step inside a scenario.
   *
   * @param   {string}  i Text that needs to be converted to MD
   * @param   {int}     k Key location of current item
   * @returns {null}    Does not return anything
   */
  function buildStep(i, k){
    STEP++; // add one to step
    STEP_I = 1; // set step back to 0
    $(ELEMENT)
      .find('lush-row')
      .append('<lush-column id="step_' + STEP + '"></lush-column>');
  }

  /**
   * Build a scenario in the main section
   *
   * @param   {string}  i Text that needs to be converted to MD
   * @param   {int}     k Key location of current item
   * @param   {object}  e Element to add data to
   * @returns {null}    Does not return anything
   */
  function buildScenario(i, k){
    SCENARIO++; // add one to scenario
    $(ELEMENT)
      .html('<lush-row></lush-row>');

    $('lush-subtitle').text(i.trim());
  }

  /**
   * Add the service title to the document.
   *
   * @param   {string}  i Text that needs to be converted to MD
   * @param   {int}     k Key location of current item
   * @returns {null}    Does not return anything
   */
  function buildSerice(i, k){
    $('lush-title')
      .text(i.trim());
  }

  /**
   * Validate if the Blueprint markdown is propperly setup.
   *
   * @param {string}  n Option that should be available.
   * @param {string}  f Full text of available tag
   * @return {bool} shows if step is allowed yes or no
   */
  function validateStep(n, f){
      if(ALLOWED_OPTIONS.indexOf(n.replace('$', '')) !== -1){
        return true;
      } else {
        $('lush-title')
          .parent()
          .append('<h4 class="blueprint-error" style="color:red">' +
              'Oops, your markdown looks to be wrong. Issue found with: <i>' + f[0] + '</i></h4>');
        console
          .warn('Oops, "' + f[0] + '" is not a valid Blueprint indentifier.');
        console
          .warn('Check the markdown allowed syntaxes document in the blueprint repo');
        return false;
      }
  }

  /**
   * Get the first line of markdown, this is to find the Blueprint ($) sign.
   *
   * @param {string}  i Get the first line from the input (i)
   * @return {string} Remove all except for first line
   */
  function createFirstLine(i){
    if(typeof i !== 'undefined') {
      return i.match(/^(.*)$/m);
    }
  }

  /**
   * Get a clean first line of markdown, this removes the Blueprint sign, used to present to user
   *
   * @param   {string}  i Get the first line from the input (i)
   * @returns {string} All to lowercase and only keep alpha characters
   */
  function createFirstLineClean(i){
    return i
        .replace(/\s+/g, '')
        .toLowerCase();
  }

  /**
   * Enables the screenshot option
   * @returns {null} Does not return anything
   */
  function enableScreenshot(){
    /**
     * Enable onclick event
     */
    if($('#lush--download-img').length){
      $('#lush--download-img').unbind('click');

      $('#lush--download-img')
        .click(function (){
          $(this).hide();

          $('lush')
            .find('img')
            .each(function(){
              var imgStr = $(this).attr('src');
              var thisImg = $(this);
              toDataUrl(imgStr, function(base64Img){
                thisImg.attr('src', base64Img);
                thisImg.attr('data-lush-original', imgStr);
              }, 'image/png');
            });

          setTimeout(function(){

            var hiddenElements = $('body').find(':hidden').not('script');
            hiddenElements.each(function() {
              if($(this).css("display") == "none") {
                $(this).addClass('lush--hidden-task');
              }
            });
            
            $('lush').siblings().hide();
            $('lush').parents().siblings().hide();
            $('lush-title').show();
            $('lush-subtitle').show();

            html2canvas( $('body') )
              .then(function(canvas) {
                  if (navigator.userAgent.indexOf('Safari') != -1 && navigator.userAgent.indexOf('Chrome') == -1) {
                    location.assign(canvas.toDataURL()); // safari, so open same windown
                  } else {
                    window.open(canvas.toDataURL());
                  }
                  $('lush').siblings().show();
                  $('lush').parents().siblings().show();
                  
                  $('lush').find('.lush--hidden-task').removeClass('lush--hidden-task');
                  $('.lush--hidden-task').hide();
                  $('.lush--hidden-task').removeClass('lush--hidden-task');

                  $('lush')
                    .find('img')
                    .each(function(){
                      var imgStr = $(this).attr('data-lush-original');
                      $(this).attr('src', imgStr);
                    });

                  $('#lush--download-img').show();

              });
          }, 2000); // timeout because there is no callback to html2canvas
        });
    }
  }

  /**
   * Animate the entrance of blueprint blocks
   * @returns {null} Does not return anything
   */
  function animateEntrance(){
    var timerMs = 0;
    var counter = 1;
    $('lush-layer')
      .each(function (i, v){
        var fadeInElement = $(this);
        setTimeout(function (){
          fadeInElement
            .animate({
              opacity: 1,
              marginTop: '0px'
            }, 275);

          if(counter++ === $('lush-layer').length){
            enableScreenshot();
          }
        }, timerMs);
        timerMs += 25;
      });
  }

  /**
   * Break the complete markdown in chunks per Blueprint character ($)
   *
   * @param   {string}  i Complete markdown document
   * @param   {object}  e Element to add LUSH to
   * @returns {object}  Returns promise object
   */
  function parseDocument(i, e){
    var promise = jQuery.Deferred(); // add deferred for promise

    PARSED = i.match(/(\$[^$]*(?=\$|$))/g);
    PARSED.forEach(function (singleVal, singleKey){
      var firstLine = createFirstLine(singleVal);
      // remove spaces and all to lowercase for weakly typing
      var firstLineClean = createFirstLineClean(firstLine[0]);

      /**
       * Remove lush element if it exsists
       */

      /**
       * Replace the element
       */
      e.replaceWith('<lush></lush>');
      ELEMENT = $('lush');

      if(validateStep(firstLineClean, firstLine) === true){
        switch (firstLineClean) {
          case '$service':
            // replace the handle to keep markdown content
            buildSerice(singleVal.replace(firstLine[0], ''), singleKey);
            break;
          case '$scenario':
            buildScenario(singleVal.replace(firstLine[0], ''), singleKey);
            break;
          case '$step':
            buildStep(singleVal.replace(firstLine[0], ''), singleKey);
            break;
          default:
            buildLayer(singleVal.replace(firstLine[0], ''), singleKey, firstLineClean, firstLine[0]);
        }
      } else {
        return promise
            .reject();
      }
    });

    return promise.resolve(); // resolve, not async
  }

  /**
   * Sets the shadowDOM of all layers
   *
   * @returns {null} Does not return anything
   */
  function setShadowDOMLayers(){
    /**
     * Add custom CSS to all available elements in lush-layer
     */
    [].forEach.call(document.querySelectorAll('[class^="lush-layer-"]'), function (hostVal) {
      /**
       * ShadowDOM is dept
       *
       * var _root   = hostVal.createShadowRoot();
       */
      var _style = '';
      switch (hostVal.className) {
        case 'lush-layer-stepdefinition':
          _style += '.' + hostVal.className + ' { background-color: transparent; color: #000 }';
          break;
        case 'lush-layer-channel':
          _style += '.' + hostVal.className + ' { background-color: #6fa8dc; color: #FFF}';
          _style += '.' + hostVal.className + '::after { content: "Channel"; text-align: right; display: block }';
          break;
        case 'lush-layer-actor':
          _style += '.' + hostVal.className + '{ background-color: #93c47d; color: #FFF }';
          _style += '.' + hostVal.className + '::after { content: "Actor"; text-align: right; display: block }';
          break;
        case 'lush-layer-apisystem':
          _style += '.' + hostVal.className + ' { background-color: #8493a1; color: #FFF }';
          _style += '.' + hostVal.className + '::after { content: "API / System"; text-align: right; display: block }';
          break;
        case 'lush-layer-observationfact':
          _style += '.' + hostVal.className + ' { background-color: #a6e0ff; color: #FFF }';
          _style += '.' + hostVal.className + '::after { content: "Observation/Fact"; text-align: right; display: block }';
          break;
        case 'lush-layer-policyrule':
          _style += '.' + hostVal.className + ' { background-color: #f6b26b; color: #FFF }';
          _style += '.' + hostVal.className + '::after { content: "Policy, Rule"; text-align: right; display: block }';
          break;
        case 'lush-layer-metric':
          _style += '.' + hostVal.className + ' { background-color: #8e7cc3; color: #FFF }';
          _style += '.' + hostVal.className + '::after { content: "Metric"; text-align: right; display: block }';
          break;
        case 'lush-layer-criticalmoment':
          _style += '.' + hostVal.className + ' { background-color: #e06666; color: #FFF }';
          _style += '.' + hostVal.className + '::after { content: "Critical moment"; text-align: right; display: block }';
          break;
        case 'lush-layer-question':
          _style += '.' + hostVal.className + ' { background-color: #3d85c6; color: #FFF }';
          _style += '.' + hostVal.className + '::after { content: "Question"; text-align: right; display: block }';
          break;
        case 'lush-layer-idea':
          _style += '.' + hostVal.className + ' { background-color: #f1c232; color: #FFF }';
          _style += '.' + hostVal.className + '::after { content: "Idea"; text-align: right; display: block }';
          break;
        default:
          break;
      }
      if($('#rootStyle').length === 0){
        $('<style id="rootStyle"></style>')
          .prependTo('head');
      }

      $('#rootStyle')
        .append(_style);
    });
  }

  /**
   * Inits editor to add and update blueprints
   *
   * @returns {null} Does not return anything
   */
  function initEditor(){
    /**
     * Make dragable
     */

    $('lush-layer')
      .draggable({
        revert: 'invalid'
      });

    $('lush-column')
      .sortable()
      .disableSelection();

    /**
     * Make dropable
     */
    $('lush-column')
      .droppable({
        activeClass: 'blueprint_column_default',
        drop: function (event, ui) {
              $(this)
                .append($(ui.draggable));
              $(ui.draggable)
                .css({
                  left: '0px',
                  top: '0px'
                });
              /**
               * If there is nothing, close it.
               */
              $('lush-column')
                .each(function (){
                  if($(this).children('lush-layer').length === 0){
                    $(this)
                      .animate({
                        width: '0px'
                      }, 'fast', function (){
                        $(this)
                          .remove();
                      });
                  }
                });
          }
        });

  }

  /**
   * Prezentation mode
   *
   * @returns {null} Does not return anything
   */
  function startPreziMode(){
    $('body > :not(lush)')
      .hide();
    $('lush-layer')
      .css('opacity', 0);
    screenfull
      .request();
    /**
     * Animate entrance after 100ms
     */
    $('lush-layer')
      .each(function (index) {
          $(this)
            .delay(100 * index)
            .animate({
              opacity: 1
            }, 'fast');
      });

    /**
     * Show everything when closed
     */
    document.addEventListener(screenfull.raw.fullscreenchange, function () {
        if(screenfull.isFullscreen === false){
          $('body > :not(lush)')
            .show();
      }
    });
  }

  /**
   * RUN
   */
  if(ELEMENT.prop('nodeName') === 'TEXTAREA'){
    MDDATA = ELEMENT.val(); // textarea, get value. set data to be available in this scope
  } else {
    MDDATA = ELEMENT.text(); // not textarea, set data to be available in this scope
  }

  var onlyRunsOnes = true; //runs the first time, but if false, it doesn't run anymore

  /**
   * Nothing is set, so take first one
   */
  parseDocument(MDDATA, ELEMENT)
    .then(function (){
      animateEntrance();
    })
    .then(function (){
      setShadowDOMLayers();
    })
    .then(function (){
      /**
       * PREZI MODE
       */
      /**
       * start clicker: 116
       * stop  clicker: 27
       * left  clicker: 33
       * right clicker: 34
       *
       * right keypad : 39
       * left keypad  : 37
       */
      /**
       * Start/stop prezi based on clicker
       */
      $(document).keydown(function (e) {
        if(e.which === 116){
          /**
           * START
           */
          startPreziMode();
        }
      });

      /**
       * If presentation button #lush-prezi is available make it clickable
       */
      if($('#lush-prezi').length){
        $('#lush-prezi').unbind('click');
        $('#lush-prezi')
          .click(function (){
            startPreziMode();
          });
      }
    })
    .then(function (){

      if(onlyRunsOnes === true){

        onlyRunsOnes = false;

        /**
         * Set download buttons
         */
        if($('#lush--download-md').length){
          $('#lush--download-md').unbind('click');
          $('#lush--download-md').click(function (){
            var content = lush2markdown($('lush-title').text(), $('lush-subtitle').text(), $('lush'));
            var textFile = null;
            var makeTextFile = function (text) {
              var data = new Blob([text], {type: 'text/plain'});

              // If we are replacing a previously generated file we need to
              // manually revoke the object URL to avoid memory leaks.
              if (textFile !== null) {
                window.URL.revokeObjectURL(textFile);
              }

              textFile = window.URL.createObjectURL(data);

              return textFile;
            };
            var result = makeTextFile(content.markdown);

            window.open(result, '_blank');

          });
        }

        /**
         * Set upload button
         */
        if($('#lush--upload').length){
          $('#lush--FileUpload').remove();
          $('body').append('<input type="file" name="lush--FileUpload" id="lush--FileUpload" style="display:none">');
          $('#lush--FileUpload').unbind('click');
          $('#lush--upload').click(function (){
            $('#lush--FileUpload').click();
            var inputElement = document.getElementById('lush--FileUpload');
            function handleFiles() {
              var fileList = this.files;
              var reader = new FileReader();
              if(this.files[0].type !== 'text/markdown'){
                alert('Hmm... This doesn\'t look like Markdown. Are you using the .md extension?');
              } else {
                 reader.onload = function (){
                    $('lush').replaceWith('<textarea id="lushAllTheThings">' + reader.result + '</textarea>');
                    markdown2lush($('#lushAllTheThings'));
                  };
                  reader.readAsText(this.files[0]);
              }
            }
            inputElement.addEventListener('change', handleFiles, false);
          });
        }
        /**
         * Set save button
         */
        if($('#lush--save').length){
          $('#lush--save').unbind('click');
          $('#lush--save').click(function (){
            var contents = lush2markdown($('lush-title').text(), $('lush-subtitle').text(), $('lush'));
            sessionStorage.setItem('lush--blueprint-title',  contents.title);
            sessionStorage.setItem('lush--blueprint-markdown', contents.markdown);
            alert('SAVED!');
          });
        }
        /**
         * Set load button
         */
        if($('#lush--load').length){
          $('#lush--load').unbind('click');
          $('#lush--load').click(function (){
            if(sessionStorage.getItem('lush--blueprint-markdown') !== null){

              var sessionResultTitle = sessionStorage.getItem('lush--blueprint-title');
              var sessionResultMarkdown = sessionStorage.getItem('lush--blueprint-markdown');

              $('#lush--markdownLush-switch').click();
              $('#lushAllTheThings').val(sessionResultMarkdown);
              $('#lush--markdownLush-switch').click();

            }
          });
        }

      }
    })
    .then(function (){
      $('lush')
        .css('display', 'block');
    });

    CURRENTMD = 0;
};

/**
 * Exec when document is ready
 *
 * @returns {object}  Returns promise object
 */
$(document).ready(function () {
  /**
   * Register new custom elements
   *
   * @param {string}  i Name of new element
   * @returns {object}  Returns promise object
   */
  function registerLushElement(i){
    var NewElement = document
        .registerElement(i, {
          prototype: Object
                .create(
                  HTMLElement
                    .prototype
                )
        });
  }

  /**
   * Set shadowDOM of elements
   *
   * @param {string}  i Name of new element
   * @param {string}  css the CSS object
   * @returns {object}  Returns promise object
   */
  function setShadowDOM(i, css){
    [].forEach.call(document.getElementsByTagName(i), function (hostVal) {
      /**
       * Deprecated the use of the shadowDOM, it's now prepended to the head
       *
       * var _root = hostVal.createShadowRoot();
       *     _root.innerHTML = '<style>' + i + css + '</style><content></content>';
       */
      if($('#rootStyle').length === 0){
        $('<style id="rootStyle" />')
          .prependTo('head');
      }

      $('#rootStyle')
        .append(i + css);

    });
  }

  /**
   * Register custom elements
   */
  registerLushElement('lush-row');
  registerLushElement('lush-layer');
  registerLushElement('lush-column');
  registerLushElement('lush-title');
  registerLushElement('lush-subtitle');

  /**
   * Add shadowDOMs
   */
  setShadowDOM('lush-column',  '{ position: relative; float: left; background-color: #f3f3f3; display:block; padding: 0.5rem; margin-left: 0.5rem; width: 26rem }');
  setShadowDOM('lush-title',   '{ display:block; font-size:2rem; -webkit-margin-before:0.67em;-webkit-margin-after:0.67em;-webkit-margin-start:0px;-webkit-margin-end:0px;font-weight:bold;}');
  setShadowDOM('lush-subtitle','{ display:block; font-size:1.125rem; -webkit-margin-before:0.67em;-webkit-margin-after:0.67em;-webkit-margin-start:0px;-webkit-margin-end:0px;font-weight:bold;}');
  setShadowDOM('lush-layer',   '{ display:block; padding:0.25rem; margin-bottom: 0.25rem } ');
});
